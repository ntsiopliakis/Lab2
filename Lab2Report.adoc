:imagesdir: Images
:figure-caption: Рисунок

== Лабораторная работа №2
=== Задание А
. `_Создать проект_`
+
Создадим новый С++ проект _Kproject2_ в IDE *IAR Embedded Workbench*. Для выполнения заданий лабораторной работы
достаточно настроек и структуры проекта по умолчанию.

. `_Создать глобальную переменную типа unsigned short и присвоить ей значение 65535. В функции main прибавить к данной переменной 1, описать что получилось и почему._`
+
Создадим переменную *var1*, произведем над ней требуемые действия (рисунок 1).
+
._Переполнение unsigned short переменной_
image::file1.png[]
+
Размер переменной с модификатором типа *short* -- 2 байта (16 бит). Все биты в представлении _n_-битной беззнаковой целочисленной переменной отводятся под хранение ее абсолютной величины, значит максимальное  хранимое в такой переменной число: 2^_n_^-1. Таким образом, запись числа *65535U* в переменную *var1* пройдет корректно (2^16^-1= *65535~10~*). При попытке инкрементировать переменную произойдет переполнение (число *65536~10~* -- 17-битное). В *var1* будет записано 16 младших бит чила *65536~10~* , т.е. ноль в каждый бит.
. `_Поменять тип переменной на signed short и присвоить ей значение 32767. В функции main прибавить к данной переменной 1 - описать что получилось и почему._`
+
Проделанные действия иллюстрирует рисунок 2.
+
._Переполнение положительной signed short переменной_
image::file2.png[]
+
Переменная  *var1* стала 16-битовой  переменной со знаком. В представлении _n_-битных целочисленных переменных со знаком старший бит резервируется под знак (0 -> "+", 1 -> "-"), а остальные _n_ - 1 бит характеризуют абсолютную величину числа по следующему правилу:
+
[#note1]
[Note]
=====================
* если _X_ - положительное число, то перед старшим битом 0 записывается _X_ как _n_-1-битное целое число, --  т. н. _прямой код числа_ (очевидно, _X~max~_ = 2^n-1^ - 1);
* если _X_ - отрицательное число, то перед старшим битом 1 записывается  ( 2^n-1^ - /_X_/ )  как _n_-1-битное целое число, --  т. н. _дополнительный код числа_ (очевидно, _X~min~_ = - 2^n-1^).
=====================
+
Таким образом, запись числа *32767* в переменную *var1* пройдет корректно (2^16-1^-1= *32767~10~*). При попытке инкрементировать переменную произойдет переполнение (число *32768~10~* -- 16-битное). В 15-ый бит, зарезервированый под знак, попадет единица, а в остальных битах установятся нули. В соответствии с изложенным выше правилом, значение переменной *var1* будет интерпретироваться как отрицательное число с абсолютной величиной /_X_/ = 2^16-1^ - 0 = *32768~10~* .

. `_Не меняя тип переменной взять адрес переменной (оператор &) - вывести адрес переменной в терминал. Не меняя переменной - явно преобразовать адрес переменной к типу указатель на short используя reinterpret_cast и присвоить локальной переменной типа short*. Должно получиться что-то типа этого:_`
+
[source,cpp]
short* ptr = reinterpret_cast<short*>(&myVar).
+
`_Вывести в терминал значение указателя - пояснить что это за значение. Разыменовать указатель и вывести в терминал значение лежащее по адресу, указанному в указателе._`
+
Проделанные действия иллюстрирует рисунок 3.
+
._Реинтерпретация указателя на переменную со знаком как указателя на беззнаковую переменную_
image::file3.png[]
+
Адрес переменной *var1* представляет собой 32-битное число (8-разрядное шестнадцатиричное), т. к. ядро микроконтроллера 32-х битное. Указатель *&var1*  указывает на положение первого байта области, занимаемой переменной *var1* в памяти микроконтроллера, и имеет тип указателя на целое двухбайтовое число со знаком. Указатель *ptr1* инициализируется указателем *&var1*, кастованным к типу указателя на целое двухбайтовое беззнаковое число. То есть, значения указателей *ptr1* и *&var1* совпадают, однако при разыменовании *ptr1* два байта, расположенные по  адресу указателя, интерпретируются как беззнаковое целое число. Битовое представление значения знаковой переменной *var1 -32768~10~*   (*0x8000*) интерпретируется как представление беззнакового числа *32768~10~*.

. `_Сделать явное преобразование этого указателя к типу указателя на int  (int*) (разыменовать указатель из предыдущего пункта типа int*). Вывести значение лежащее по адресу указателя типа int*  из предыдущего пункта. Объяснить полученный результат._`
+
Проделанные действия иллюстрирует рисунок 4.
+
._Реинтерпретация указателя на двухбайтовую переменную как указателя на четырехбайтовую переменную_
image::file4.png[]
+
Указатель *ptr2* инициализируется указателем *ptr1*, кастованным к типу указателя на *int* (целое четырехбайтовое число со знаком). То есть, при разыменовании *ptr2* четыре байта, расположенные по  адресу указателя, интерпретируются как целое число со знаком. Как видно из рисунка 4, два байта, дополняющие представление значения переменной *var1* до четырех байт, заполнены нулями. Эта четырехбайтовая область интерпретируется как битовое представление значения знаковой переменной *32768~10~* в соответствии с <<note1,правилом представления знаковых чисел>>, упомянутым в  пункте 3.

=== Задание Б

. `_Заменить тип переменной с unsigned short на short и присвоить ей значение 65535. В функции main вывести значение переменной - посмотреть её значение - объяснить эту магию._`
+
Проделанные действия иллюстрирует рисунок 5.
+
._Неявное приведение беззнакового числа к числу со знаком_
image::file5.png[]
+
В данном случае компилятор неявно приводит двухбайтовое беззнаковое целое число *65535U* к двухбайтовому целому числу со знаком. Как видим, при приведении битовое представление числа (0xffff) осталось неизменным, но интерпретируется как <<note1,число со знаком>>: единица в 15-том бите указывает на отрицательный знак, а 15-битный дополнительный код 0x7fff определяет абсолютное значение числа равным единице.
. `_Не меняя переменную в функции main сделать явное преобразование типа к short:_`
[source,cpp]
std::cout << static_cast<short>(myVar) << std::endl ;
+
`_объяснить полученный результат._`
+
Проделанные действия иллюстрирует рисунок 6.
+
._Явное приведение беззнакового числа к числу со знаком_
image::file6.png[]
+
В данном случае использование *static_cast* явно указывает компилятору на необходимость приведения типов, что позволяет избежать предупреждений от компилятора. Само приведение происходит аналогично предыдущему случаю.

=== Задание В

. `_Создать переменную типа float и присвоить ей значение 4'000'000'000F, прибавить к этому значению 1.0f -  вывести значение в окно Watch, объяснить полученный результат._`
+
Проделанные действия иллюстрирует рисунок 7.
+
._Потеря точности при сложении чисел с плавающей запятой одинарной точности_
image::file7.png[]
+
Видим, что число *4 000 000 001* не представимо числом с плавающей запятой одинарной точности (тип *float*) и заменяется ближайшим представимым числом *4 000 000 000.0f*.
. `_Заменить тип переменной float на double. Прибавить к этому значению 1.0f - вывести в окно Watch - объяснить полученный результат_`
+
Проделанные действия иллюстрирует рисунок 8.
+
._Проверка точности сложения чисел с плавающей запятой двойной точности_
image::file8.png[]
+
Видим, что число *4 000 000 001* представимо числом с плавающей запятой двойной точности (тип *double*). Увеличение точности обеспечивается удвоенным размером типа *double*  по сравнению с *float* (два машинных слова, 8 байт).
